<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Demo Project</title>
</head>
<body>
    <form id="myForm" action="../process_data.py" method="post">
        <!-- 1. Text-box for the input information -->
        <textarea name="data" id="inputText" placeholder="Enter your text here..."></textarea>
        <!-- 2. Button that submits the result -->
        <button type="button" onclick="submitData()">Submit</button>
    </form>

    <!-- 3. Area for the output from backend -->
    <div id="outputArea">
           <svg width="900" height="800"></svg>
           <style>

            .links line {
              stroke: #999;
              stroke-opacity: 0.6;
            }

            .nodes circle {
              stroke: #fff;
              stroke-width: 1.5px;
            }

            text {
              font: 10px sans-serif;
              pointer-events: none;
              text-shadow: 0 1px 0 #fff, 1px 0 0 #fff, 0 -1px 0 #fff, -1px 0 0 #fff;
            }

            </style>

            <script src="https://d3js.org/d3.v4.min.js"></script>
            <script>

            d3.json("graph_force.json", function(error, graph) {
              var svg = d3.select("svg"),
                width = +svg.attr("width"),
                height = +svg.attr("height");

            var color = d3.scaleLinear().range(['blue', 'red']);;

            var simulation = d3.forceSimulation()
             .force("link", d3.forceLink().id(function(d) { return d.id; }).distance(150))
             .force("charge", d3.forceManyBody().strength(-300))
             .force("center", d3.forceCenter(width / 2, height / 2));

            var link = svg.append("g")
              .attr("class", "links")
              .selectAll("line")
             .data(graph.links)
             .enter().append("line")
              .attr("stroke-width", function(d) { return d.c*30 })
              .attr('opacity', function(d)  {return 0.5; })
              .style('stroke', function(d) { if (d.sent == "neg"){return "red"}; return "blue"; })


            var node = svg.selectAll(".node")
                        .data(graph.nodes)
                        .enter().append("g")
                                    .attr("class", "node")
                         .call(d3.drag()
                  .on("start", dragstarted)
                  .on("drag", dragged)
                  .on("end", dragended));

            node.append("circle")
              .attr("r", function(d) { return 10; })
              .attr("fill", function(d) { return "black"; })
              .attr('fill-opacity', function(d) { return d.c / 17249; })
              ;

            node.append("text")
                .text(function(d) { return d.id; });

             simulation
               .nodes(graph.nodes)
               .on("tick", ticked);

             simulation.force("link")
               .links(graph.links);

             function ticked() {
               link
                .attr("x1", function(d) { return d.source.x; })
                .attr("y1", function(d) { return d.source.y; })
                .attr("x2", function(d) { return d.target.x; })
                .attr("y2", function(d) { return d.target.y; });

            node.attr("transform", function(d) {
                            padding = 10
                            if (d.x>width-padding){d.x=width-padding}
                            if (d.x<padding){d.x=padding}
                            if (d.y>height-padding){d.y=height-padding}
                            if (d.y<padding){d.y=padding}
                            return "translate(" + d.x + "," + d.y + ")";
                        });
               }

             function dragstarted(d) {
              if (!d3.event.active) simulation.alphaTarget(0.3).restart();
              d.fx = d.x;
              d.fy = d.y;
              }

             function dragged(d) {
               d.fx = d3.event.x;
               d.fy = d3.event.y;
             }

             function dragended(d) {
                if (!d3.event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
             }
            });
            </script>

        <style>
        .node {
            font: 10px sans-serif;
        }

        .link {
            stroke: steelblue;
            stroke-opacity: 0.5;
            fill: none;
            pointer-events: none;
        }
    </style>

    <script>
        var transition_time = 200
        var diameter = 960,
            radius = diameter / 2,
            innerRadius = radius - 120;
        var cluster = d3.cluster()
            .size([360, innerRadius]);
        var line = d3.radialLine()
            .curve(d3.curveBundle.beta(0.85))
            .radius(function (d) {
                return d.y;
            })
            .angle(function (d) {
                return d.x / 180 * Math.PI;
            });
        var svg = d3.select("body").append("svg")
            .attr("id", "svg")
            .attr("width", diameter)
            .attr("height", diameter)
            .append("g")
            .attr("transform", "translate(" + radius + "," + radius + ")");
        var link = svg.append("g").selectAll(".link"),
            node = svg.append("g").selectAll(".node");

        d3.json("graph_radial.json", function (error, classes) {
            if (error) throw error;
            function calculate_opacity(d) {
                var target = d.target.data.name, weight = undefined, sent = undefined
                for (const source of d.source.data.imports) {
                    if (source.name === target) {weight = source.w, sent = source.sent}
                }
                if (weight !== undefined) {return weight * 10}
                return 1
            }

            function calculate_color(d){
                var target = d.target.data.name, weight = undefined, sent = undefined
                    for (const source of d.source.data.imports) {
                        if (source.name === target) {
                            weight = source.w
                            sent = source.sent
                        }
                    }
                    if (sent === "neg") {return "red"}
                    if (sent === "pos") {return "green"}
                    return "black"
            }

            var root = packageHierarchy(classes).sum(function (d) {return d.w;});
            cluster(root);
            link = link
                .data(packageImports(root.leaves()))
                .enter().append("path")
                .each(function (d) {d.source = d[0], d.target = d[d.length - 1];})
                .attr("class", "link")
                .attr("d", line)
                .attr("id", function (d) {
                    if (d.data !== undefined) {return null}
                    return d.target.data.name + "***" + d.source.data.name
                })
                .attr("stroke-width", function (d) {
                    var target = d.target.data.name, weight = undefined, sent = undefined
                    for (const source of d.source.data.imports) {
                        if (source.name === target) {weight = source.w, sent = source.sent}
                    }
                    if (weight !== undefined) {return weight * 10}
                    return 1
                })
                .attr('opacity', function (d) {return calculate_opacity(d)})
                .style("stroke", function (d) {return calculate_color(d)})


            node = node
                .data(root.leaves())
                .enter().append("text")
                .attr("class", "node")
                .attr("dy", "0.31em")
                .attr("transform", function (d) {return "rotate(" + (d.x - 90) + ")translate(" + (d.y + 8) + ",0)" + (d.x < 180 ? "" : "rotate(180)");})
                .attr("text-anchor", function (d) {return d.x < 180 ? "start" : "end";})
                .text(function (d) {
                    return d.data.key;
                }).on('mouseover', function (d_parent) {
                    name = d_parent.data.name
                    d3.selectAll("[id*='***']")
                        .transition().duration(transition_time)
                        .attr('opacity', 0)
                        //.style('stroke', 'grey');
                    d3.selectAll("[id*='" + name + "']")
                        .transition().duration(transition_time)
                        .attr('opacity', function (d) {return calculate_opacity(d)})
                        //.style('stroke', function (d) {return calculate_color(d)});
                }).on('mouseout', function (d_parent) {
                    name = d_parent.data.name
                    d3.selectAll("[id*='***']")
                        .transition().duration(transition_time)
                        .attr('opacity', function (d) {return calculate_opacity(d)})
                        //.style('stroke', function (d) {return calculate_color(d)});
                })
        });

        // Lazily construct the package hierarchy from class names.
        function packageHierarchy(classes) {
            console.log(classes)
            var map = {};

            function find(name, data) {
                var node = map[name], i;
                if (!node) {
                    node = map[name] = data || {name: name, children: []};
                    if (name.length) {
                        node.parent = find(name.substring(0, i = name.lastIndexOf(".")));
                        node.parent.children.push(node);
                        node.key = name.substring(i + 1);
                    }
                }
                return node;
            }

            classes.forEach(function (d) {
                find(d.name, d);
            });
            return d3.hierarchy(map[""]);
        }

        // Return a list of imports for the given array of nodes.
        function packageImports(nodes) {
            var map = {},
                imports = [];
            // Compute a map from name to node.
            nodes.forEach(function (d) {
                map[d.data.name] = d;
            });
            // For each import, construct a link from the source to target node.
            nodes.forEach(function (d) {
                if (d.data.imports) d.data.imports.forEach(function (i) {
                    //console.log(d)
                    // d.data.w_l = i["w"]
                    // d.data.sent = i["sent"]
                    imports.push(map[d.data.name].path(map[i["name"]]));
                });
            });
            return imports;
        }
    </script>
    </div>

    <script>
        function submitData() {
            const form = document.getElementById('myForm');

            fetch(form.action, {
                method: 'POST',
                body: new FormData(form)
            })
            .then(response => response.text())
            .then(data => {
                document.getElementById('outputArea').innerText = data;
            })
            .catch(error => {
                console.error('Error:', error);
            });
        }
    </script>
</body>
</html>